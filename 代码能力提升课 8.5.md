# 代码能力提升课 8.5

### 欧拉计划 05

2520是可以除以1到10中的每个数字而没有任何余数的最小数字。

可以被1到20的所有数字整除的最小正数是多少？

```c
#include <stdio.h>

int gcd(int a, int b){
	return (b ? gcd(b, a % b) : a);
}
int main(){
	int ans = 1;
	for(int i = 1; i < 20; i++){
		ans *= i / gcd(ans, i);
	}
	printf("%d\n", ans);
	return 0;
}
```

lcm(最小公倍数) = a*b/gcd（a，b）（最大公因数）

A = x * gcd (A,B)   B = x * gcd(A,B) 

gcd (x,y) = 1 , x * y * gcd(A,B) = lcm (A,B) = A*B/gcd(A,B)

欧几里得算法（辗转相除法）

```c
int gcd(int a,int b) {
    return (b ? gcd(b, a % b) : a);
}
```

gcd (A,B) = gcd (B,A % B)  exp:(12,8) -> (8,4)

证明： gcd(A,B) = gcd(B,A%B)

设 gcd(A,B) = c, A = x * c , B = y * c; gcd (x,y) = 1；

A % B = (x - ky) * c ; gcd(A,B) = gcd(y * c, (x-ky) * c)

等价于证明 gcd(y,x-ky) = 1

设gcd(y,x-ky) = d; y =nd; x= (m-kn)d;

因为 gcd(x,y) =1 所以 d = 1 gcd(y,x-ky) = 1;

证明完毕。

### 欧拉计划 07

通过列出前六个素数：2,3,5,7,11和13，我们可以看到第6个素数是13。

什么是10 001主数？

```c
#include <stdio.h>
#include <string.h>
#define max_n 200000

int prime[max_n + 5];

int main() {
    memset(prime, 0, sizeof(prime));//初始化数组为0
    for(int i = 2; i <= max_n; i ++) {
        if (!prime[i]) {  //等同于prime[i]==0
            prime[++prime[0]] = i;
            for (int j = 2; j * i <= max_n; j++) {
                prime[j * i] = 1;//i的倍数是合数，标记为1
            }
        }
    }
    printf("%d\n", prime[10001]);
    return 0;
}
```

知识要点：素数筛

使用标记数组来标记当前数字是素数还是合数。

1.使用prime[i]来标记i是否是合数

2.标记为1的数字为合数，否则为素数

3.第一次知道2是素数，则将2的倍数标记为1

4.向后找到第一个没有被标记的数字i

5.将i的倍数全部标记为合数

6.重复4--6步，知道标记完范围内的所有数字。

```c
#include<stdio.h>

#define max_n 200000

int prime[max_n + 5] = {0};

int main() {
    for(int i = 2; i <= max_n; i++) {
        if(!prime[i]) prime[++prime[0]] = i;
        for (int j = 1; j <= prime[0]; j++) {
            if (i * prime[j] > max_n) break;
            prime[i * prime[j]] = 1;
            if (i % prime[j] == 0) break;
        }
    }
    printf("%d\n",prime[10001]);
    return 0;
}

```

知识要点：线性筛

1.标记一个范围内的数字是否是合数，没有被标记的则为素数

2.算法的空间复杂度为O(N),时间复杂度为O(N)

3.总体思想使用一个整数M取标记合数N，其中N和M具有如下性质：

1.N中最小素数为p

2.N可以表示成为p*M  (一个合数一定能够成为两个或几个素因子乘积)

3.p一定小于等于M中最小的素因子

4.利用M * p‘(所有不大于M中最小素数的集合)标记N1,N2,N3...

虽然是和数，也要计算他和最小素因子的乘积，然后标记掉。

### 欧拉计划 08

具有最大乘积的1000位数字中的四个相邻数字是9×9×8×9 = 5832。

73167176531330624919225119674426574742355349194934 
96983520312774506326239578318016984801869478851843 
85861560789112949495459501737958331952853208805511 
12540698747158523863050715693290963295227443043557 
66896648950445244523161731856403098711121722383113 
62229893423380308135336276614282806444486645238749 
30358907296290491560440772390713810515859307960866 
70172427121883998797908792274921901699720888093776 
65727333001053367881220235421809751254540594752243 
52584907711670556013604839586446706324415722155397 
53697817977846174064955149290862569321978468622482 
83972241375657056057490261407972968652414535100474 
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586 
17866458359124566529476545682848912883142607690042 
24219022671055626321111109370544217506941658960408 
07198403850962455444362981230987879927244284909188 
84580156166097919133875499200524063689912560717606 
05886116467109405077541002256983155200055935729725 
71636269561882670428252483600823257530420752963450

找到具有最大产品的1000位数字中的十三个相邻数字。这个产品有什么价值？

```c
#include <stdio.h>
#include <inttypes.h>
#include <string.h>
#include "008.H"


int main() {
    int64_t p = 1, zero = 0, ans = 0;
    for (int i = 0; num[i]; i++) {
        if (num[i] == '0') {
            zero += 1;
        } else {
            p *= (num[i] - '0');//数组存储的是字符类型
        }
        if (i >= 13) {
            if (num[i - 13] == '0') {
                zero -= 1;
            } else {
                p /= (num[i - 13] - '0');
            }
        }
        if (zero == 0 && p > ans) ans = p;
    }
    printf("%" PRId64 "\n", ans);
    return 0;
}
```

通过自行设置头文件将数据写入头文件来进行输入。

知识要点：滑动窗口法 、 逆运算

逆运算：逆运算是一种法则，假设A是一个非空集合，对A中任意两个元素a和b，通过某种法则X，使A中有唯一确定的元素c与他们对应，我们就说这个法则是A中的一种运算。如果一直c和a、b中的一个，按照某种法则W可以得到另外一个元素，那么在集合A上，这样的法则W成为法则X的逆运算。

1.在实数集上，减法是加法的逆运算，反过来不成立。

2.在非零整数集上，除法是乘法的逆运算，反过来不成立。

3.题目中所涉及的数据范围为10以内的非负整数集（含0）

4.由于在0处，除法不能成为乘法的逆运算，所以需要对0以特殊处理。

