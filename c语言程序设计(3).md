# c语言程序设计(3)

## 函数

函数的特点：

相对于过程式编程，函数式编程能够使结构更加清晰整洁

函数说明：

```c
int is_prime(int x) {
    for (int i = 2; i <= x / 2; ++i) {
        if (x % i == 0) {
            return 0;
        }
    }
    return 1;
}
```

说明：

1.int 返回值

2.is_prime 函数名

3.int x 参数声明列表

#### 函数的声明与定义

程序在编译过程中的过程分为几个部分：

预处理 -> 编译 ->  ->对象文件.o

​                               ->链接 ->可执行程序

.c/.cpp 源文件 对应一个.o对象文件  （只要没有语法错误就可以生成）

未定义这个错误发生在链接过程。

可以定义在不同的文件里，然后对两个不同的对象文件进行链接（生成可执行文件）

```c
g++ 5.function.o 5.unit.o
```

```c
// 5.function.cpp
#include <stdio.h>

int funcA(int);
int funcB(int);

int main() {
    funcA(6);
    funcB(6);
    return 0;
}

int funcB(int n) {
    printf("funcB : %d\n", n);
    if (n == 0) return 0;
    funcA(n - 1);
    return n;
}

/*
int funcA(int n) {
    printf("funcA : %d\n", n);
    if (n == 0) return 0;
    funcB(n - 1);
    return n;
}
*/
```

```c
// 5.unit.cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
using namespace std;

int funcA(int);

int funcB(int n) {
    printf("funcB : %d\n", n);
    if (n == 0) return 0;
    funcA(n - 1);
    return n;
}

int funcA(int n) {
    printf("funcA : %d\n", n);
    if (n == 0) return 0;
    funcB(n - 1);
    return n;
}
```

随堂练习1：

请实现一个程序，先读入两个整数，k，b。输出y = k*x+b 直线方程中 x=1 到 x=100 时的y的值

```c
#include <stdio.h>
int f(int k, int b, int x) {
    return k * x + b; 
}

int main() {
    int k, b;
    scanf("%d%d", &k, &b);
    for (int i = 1; i <= 100; ++i) {
        printf("f(%d) = %d\n", i, f(k, b, i));
    }
    return 0;
}
```

#### K&R凤格的函数定义

```c
int is_prime(x)
int x;
{
    for (int i = 2; i * i <= x; i++) {
        if (x % i == 0) return 0;
    }
    return 1;
}
```

该风格的函数定义比较古老，不推荐使用。

### 递归程序

定义：程序调用自身的变成技巧叫做【递归】

递归程序的组成成分

1.要定义明确的传入参数和函数意义

2.边界条件处理

3.针对于问题的『处理过程』和『递归过程』

4.结果返回

练习题二：

```c
#include <stdio.h>
int factorial(int n){
 	if(n == 1) return 1;
    return factorial(n-1)*n;
}
int main() {
    int n;
    scanf("%d", &n);
    printf("%d",factorial(n));
    return 0;
}
```

### 函数指针

```c
int g(int (*f1)(int), int (*f2)(int), int (*f3)(int),int x){
    if (x < 0) {
        return f1(x);
    }
    if (x < 100) {
   		return f2(x);
    }
    return f3(x);
}        
```

函数传入参数的类型可以是指针，具体定义方式如上所示

### 欧拉计划45题 函数指针的应用

**Triangular, pentagonal, and hexagonal**

Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:

|            |              |                     |
| :--------- | :----------- | :------------------ |
| Triangle   | Tn=n(n+1)/2  | 1, 3, 6, 10, 15, …  |
| Pentagonal | Pn=n(3n−1)/2 | 1, 5, 12, 22, 35, … |
| Hexagonal  | Hn=n(2n−1)   | 1, 6, 15, 28, 45, … |

It can be verified that T285 = P165 = H143 = 40755.

Find the next triangle number that is also pentagonal and hexagonal.

**三角形数、五边形数和六角形数**

三角形数、五边形数和六角形数分别由以下公式给出：

|          |              |                     |
| :------- | :----------- | :------------------ |
| 三角形数 | Tn=n(n+1)/2  | 1, 3, 6, 10, 15, …  |
| 五边形数 | Pn=n(3n−1)/2 | 1, 5, 12, 22, 35, … |
| 六边形数 | Hn=n(2n−1)   | 1, 6, 15, 28, 45, … |

可以验证，T285 = P165 = H143 = 40755。

找出下一个同时是三角形数、五边形数和六角形数的数。

```c
typedef int64_t (*calcFunc)(int64_t);

int64_t Hexagonal(int64_t n) {
    return n * (2 * n - 1);
}
int64_t Pentagonal(int64_t n) {
    return n * (3 * n - 1) / 2;
}
int64_t Triangle(int64_t n) {
    return n * (n + 1) / 2;
}
```

代码讲解：

  calcFunc函数表示为传入64位整形并且返回64位整形的一个函数指针类型

  Hexagonal函数表示传入一个64位整形并且返回第n个六边形数

  Pentagonal函数表示传入一个64位整形并且返回第n个五边形数

  Triangle函数表示传入一个64位整形并且返回第n个三边形数

注意：Hexagonal、Pentagonal和Triangle均为单调递增函数。

1. 因为是单调递增函数，所以可以使用二分法来求单调递增函数的一个值。

2. 从题目给的公式可以看出来，六边形的不同维度空间的边数增加是最快的，所以可以用六边形边数作为要查找的目标值，三边形和五边形作为被查找的对象。

3. 二分查找需要定义一个初始查找区间，区间的开头可以取１，区间的结尾可以取要查找的值。这是因为，以上单调递增序列因变量的增加速度比自变量的增加速度快，初始区间结尾用因变量的值可以保证要查找的值一定在这个初始区间内，这样后面的二分才有意义。

二分查找的实现：

```c
bool Vaild(int64_t n, calcFunc f) {
    int64_t mind = 1, maxd = n, mid;
    int64_t t;
    mid = (mind + maxd) >> 1;
    while (mind <= maxd) {
        t = f(mid);
        if (t < n) {
            mind = mid + 1;
        } else if (t > n) {
            maxd = mid - 1;
        } else if (t == n) {
            return true;
        }
        mid = (mind + maxd) >> 1;
    }
    return false;
}
```

代码讲解：

  Vaild函数求解单调递增函数f等于n时的解，如果存在整数解则返回true，否则返回false。

### 整体代码

```c
#include<stdio.h>
#include<inttypes.h>

int64_t Triangle(int64_t n) {
    return n * (n + 1) / 2;
}

int64_t Pentagonal(int64_t n) {
    return n * (3 * n - 1) / 2;
}

int64_t Hexagonal(int64_t n) {
    return n * (2 * n - 1);
}

int64_t binary_search(int64_t (*func)(int64_t), int64_t y) {
    int64_t head = 1, tail = y, mid;
    while (head <= tail) {
        mid = (head + tail) / 2;
        if (__builtin_expect(func(mid) == y, 0)) return mid;
        if (func(mid) > y) tail = mid - 1;
        else head = mid + 1; 
    }
    return -1;
}
int main() {
    int64_t n = 143;
    while (n) {
        ++n;
        if (binary_search(Triangle, Hexagonal(n)) == -1) continue;
        if (binary_search(Pentagonal, Hexagonal(n)) == -1) continue;
        printf("%" PRId64, Hexagonal(n));
        break;
    }
    
    return 0;
}
```

